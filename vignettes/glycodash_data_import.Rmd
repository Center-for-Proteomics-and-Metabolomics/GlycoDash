---
title: "Glycodash data import"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{glycodash_data_import}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include=FALSE}
# package is not installed yet so instead of:
#library(glycodash)

# I'm using:
devtools::load_all()
# to make the package functions available in this .Rmd file
```

## Introduction

The data-import functions can be used to convert a LacyTools summary file to a format suitable for R. In addition, metadata ca be added if a metadata file and a platedesign file are available.

```{r load-data}

lacytools_file <- system.file("extdata", "Tuebingen_LacyTools_summary.txt", package = "glycodash")

data <- read_lacytools_summary(lacytools_file,
                               Ig_data = "Yes",
                               keyword_total = "Total",
                               keyword_specific = "Spike")

plate_design_file_s <- system.file("extdata",
                                 "For_plater_Tuebingen_COVID_Specific.xlsx",
                                 package = "glycodash")

plate_design_file_t <- system.file("extdata",
                                 "For_plater_Tuebingen_COVID_Total.xlsx",
                                 package = "glycodash")

plate_design_s <- read_and_process_plate_design(plate_design_file_s) %>% 
  dplyr::mutate(group = "Spike")
plate_design_t <- read_and_process_plate_design(plate_design_file_t) %>% 
  dplyr::mutate(group = "Total")

plate_design <- dplyr::full_join(plate_design_s,
                          plate_design_t)

data <- dplyr::left_join(data,
                      plate_design)

```

```{r}

cut_off_basis <- c("Spike visucon", "Spike PBS")

if ("group" %in% colnames(data)) {
  groups_to_filter <- stringr::str_extract(
    string = cut_off_basis,
    pattern = paste0(unique(data$group),
                     collapse = "|")) %>% 
    na.omit(.)
} else {
  groups_to_filter <- NULL
}

# Extract the sample_type out of input$cut_off_basis that was selected by
# the user as cut_off_basis:
sample_types_to_filter <- stringr::str_extract(
  string = cut_off_basis,
  pattern = paste0(unique(data$sample_type),
                   collapse = "|")) %>% 
  na.omit(.)


data <- define_clusters(data = data,
                        clusters_regex = "IgGI1")

checked_data <- do_criteria_check(data = data, 
                                  min_ppm_deviation = -40,
                                  max_ppm_deviation = 40,
                                  max_ipq = 0.25,
                                  min_sn = 9)

grouping_variables <- c("group", "sample_type", "cluster", "sample_name")

spectra_check <- checked_data %>% 
  # I'm using across() and any_of() because if the data is not Ig data, the
  # column "group" doesn't exist:
  dplyr::group_by(dplyr::across(tidyselect::any_of(grouping_variables))) %>% 
  dplyr::summarise(passing_proportion = sum(criteria_check)/dplyr::n(), 
                   sum = sum(criteria_check),
                   n = dplyr::n(),
                   sum_intensity = sum(absolute_intensity_background_subtracted[criteria_check == TRUE])) %>% 
  dplyr::ungroup(.)

cut_offs <- calculate_cut_offs(spectra_check = spectra_check,
                               groups_to_filter = c("Spike", "Spike"),
                               sample_types_to_filter = c("PBS", "visucon")) %>% 
  dplyr::ungroup(.)

spectra_check <- dplyr::left_join(spectra_check, cut_offs, by = "cluster") %>% 
  dplyr::ungroup(.)

passing_spectra <- spectra_check %>% 
  dplyr::filter((passing_proportion > cut_off_prop) & (sum_intensity > cut_off_sum_int))

# Turn into function:




  
cut_off_basis_samples <- filter_cut_off_basis(cut_off_basis = cut_off_basis,
                                              data = spectra_check)

create_cut_off_plot(spectra_check = spectra_check,
                    cut_off_basis_samples = cut_off_basis_samples)
  
```

