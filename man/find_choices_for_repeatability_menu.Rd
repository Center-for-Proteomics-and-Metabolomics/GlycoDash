% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fct_repeatability.R
\name{find_choices_for_repeatability_menu}
\alias{find_choices_for_repeatability_menu}
\title{Determine the choices for the repeatability sample menu}
\usage{
find_choices_for_repeatability_menu(normalized_data)
}
\arguments{
\item{normalized_data}{}
}
\value{
A list of character strings where each string contains "sample id: "
  followed by the sample ID and if applicable "group: " followed by the total
  or specific keyword. This list can be given as the \code{choices} argument
  to the function \code{\link{selectInput}}.
}
\description{
This function finds the sample ID's or if applicable the combinations of
sample ID and group (total or specific) for which there are multiple
measurements in the data.
}
\examples{
# First spectra curation has to be performed:
data("example_data")

example_data <- define_clusters(data = example_data,
                                cluster_keywords = "IgGI")

checked_data <- check_analyte_quality_criteria(my_data = example_data,
                                               min_ppm_deviation = -20,
                                               max_ppm_deviation = 20,
                                               max_ipq = 0.2,
                                               min_sn = 9,
                                               criteria_to_consider = c("Mass accuracy",
                                                                        "S/N",
                                                                        "IPQ"))

summarized_checks <- summarize_spectra_checks(checked_data = checked_data)

cut_offs_total <- calculate_cut_offs(summarized_checks = summarized_checks,
                                     control_sample_types = "PBS",
                                     exclude_sample_types = NULL,
                                     group_keyword = "Total",
                                     percentile = 97,
                                     use_mean_SD = FALSE,
                                     SD_factor = NULL,
                                     uncalibrated_as_NA = TRUE)

cut_offs_specific <- calculate_cut_offs(summarized_checks = summarized_checks,
                                        control_sample_types = "PBS",
                                        exclude_sample_types = NULL,
                                        group_keyword = "Spike",
                                        percentile = 97,
                                        use_mean_SD = FALSE,
                                        SD_factor = NULL,
                                        uncalibrated_as_NA = TRUE)

cut_offs <- dplyr::full_join(cut_offs_total,
                             cut_offs_specific)

curated_spectra <- curate_spectra(checked_data = checked_data,
                                  summarized_checks = summarized_checks,
                                  cut_offs = cut_offs)

passing_spectra <- kick_out_spectra(curated_spectra = curated_spectra)

for_analyte_curation <- remove_unneeded_columns(passing_spectra = passing_spectra)

# Then analyte curation is performed:
without_samples_to_ignore <- throw_out_samples(
   passing_spectra = for_analyte_curation,
   samples_to_ignore = c("PBS", "Visucon", "IVIGg", "Total")
)

checked_analytes <- check_analyte_quality_criteria(my_data = without_samples_to_ignore,
                                                   min_ppm_deviation = -20,
                                                   max_ppm_deviation = 20,
                                                   max_ipq = 0.2,
                                                   min_sn = 9,
                                                   criteria_to_consider = c("Mass accuracy",
                                                                            "S/N",
                                                                            "IPQ"))

curated_analytes <- curate_analytes(checked_analytes = checked_analytes,
                                    cut_off_percentage = 25)

analyte_curated_data <- dplyr::full_join(curated_analytes,
                                         for_analyte_curation) \%>\%
   dplyr::filter(has_passed_analyte_curation) \%>\%
   dplyr::select(-c(has_passed_analyte_curation, passing_percentage))

# Then we calculate the total intensities for each analyte:
total_intensities <- calculate_total_intensity(analyte_curated_data)

# And then we can perform total area normalization:
normalized_data <- normalize_data(total_intensities)

find_choices_for_repeatability_menu(normalized_data)
}
