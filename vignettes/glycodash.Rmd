---
title: "glycodash"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{glycodash}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}

#library(glycodash)
devtools::load_all()

```

This vignette is not yet finished!

## Data import

The data import functions can be used to convert a LacyTools summary file to a format suitable for R.

```{r reading-the-lacytools-summary}

lacytools_file <- system.file("extdata",
                              "LacyTools_summary_example.txt", 
                              package = "glycodash")

raw_data <- read_non_rectangular(lacytools_file)

data <- convert_lacytools_summary(raw_data) %>% 
  detect_group(.,
               keyword_specific = "Spike",
               keyword_total = "Total")

data

```

In addition, a plate design file can be processed to add sample types and sample ID's to the data.

```{r processing-the-plate-design}

plate_design_file <- system.file("extdata",
                                 "Plate_design_example.xlsx",
                                 package = "glycodash")



plate_design <- read_and_process_plate_design(plate_design_file)

data_with_platewell <- detect_plate_and_well(data)

data_complete <- dplyr::left_join(data_with_platewell,
                                  plate_design) %>% 
  tidyr::extract(col = sample_id,
                 into = c("sample_type"),
                 regex = "([[:alpha:]]+)",
                 remove = FALSE) %>% 
  define_clusters(.,
                  cluster_keywords = "IgGI1")

replicates <- data_complete %>% 
        dplyr::select(tidyselect::any_of(c("sample_name", "sample_id", "group"))) %>% 
        dplyr::distinct() %>% 
        dplyr::group_by(dplyr::across(tidyselect::any_of("group"))) %>% 
        dplyr::add_count(sample_id, name = "number_of_replicates") %>% 
        dplyr::mutate(number_of_replicates = ifelse(sample_id == "empty cell in plate design",
                                                    1,
                                                    number_of_replicates)) %>% 
        dplyr::mutate(replicates = ifelse(number_of_replicates > 1, 
                                          TRUE, 
                                          FALSE))
      
data_complete <- dplyr::full_join(replicates, data_complete) %>% 
  dplyr::ungroup(.)

data_complete

```

Finally, metadata can be added to the data.

```{r adding-metadata, eval=FALSE}

metadata_file <- system.file("extdata",
                            "Metadata_example.xlsx",
                            package = "glycodash")

metadata <- read_metadata(metadata_file,
                          "Metadata_example.xlsx")

metadata

data <- dplyr::left_join(data,
                         metadata,
                         by = c(sample_id = "sample_id"))

x <- data %>% 
  dplyr::group_by(sample_name) %>% 
  dplyr::filter(!all(is.na(absolute_intensity_background_subtracted))) %>% 
  dplyr::filter(sample_id == "PBS")

unique(x$sample_name)

```

## Spectra curation

The spectra curation functions can be used to curate spectra, based on the 
proportion of analytes within the spectrum that fulfill the analyte quality 
criteria and based on the sum intensity of those passing analytes within the 
spectrum. This proportion of passing analytes and this sum intensity are compared
to the cut-off values for both. The cut-off values are the average 
proportion of passing analytes and average sum intensity + 3 times the standard 
deviations in a chosen group of spectra that should not pass curation (cut_off_basis). 

```{r spectra-curation}


min_ppm_deviation = -20
max_ppm_deviation = 20
max_ipq = 0.2
min_sn = 9
qcs <- c("IPQ")

data_checked <- data_complete %>% 
    dplyr::mutate(`mass accuracy` = dplyr::between(mass_accuracy_ppm, 
                                            min_ppm_deviation, 
                                            max_ppm_deviation),
                  IPQ = isotopic_pattern_quality < max_ipq,
                  `S/N` = sn > min_sn) %>% 
  # rowwise() allows you to check all the criteria in qcs using c_across per row:
  dplyr::rowwise() %>% 
  dplyr::mutate(criteria_check = all(dplyr::c_across(tidyselect::all_of(qcs))) %>% 
                    tidyr::replace_na(., FALSE)) %>% 
    tidyr::pivot_longer(cols = c(`mass accuracy`, IPQ, `S/N`),
                        names_to = "criterium",
                        values_to = "passed") %>% 
    dplyr::mutate(failed_criteria = ifelse(passed == FALSE, criterium, NA)) %>% 
  dplyr::select(-c(criterium, passed)) %>% 
  dplyr::group_by(sample_name, analyte, charge) %>% 
  dplyr::summarise(failed_criteria = dplyr::if_else(
    all(is.na(failed_criteria)),
    "none",
    comma_and(unique(failed_criteria[!is.na(failed_criteria)]))
  ),
  across()) %>% 
  dplyr::distinct()


checked_data <- do_criteria_check(data_complete,
                       min_ppm_deviation = -20,
                       max_ppm_deviation = 20,
                       max_ipq = 0.2,
                       min_sn = 9,
                       qcs_to_consider = c("S/N", "IPQ", "Mass accuracy"))

summarized_checks <- check_spectra(data = data_complete,
                                 min_ppm_deviation = -20,
                                 max_ppm_deviation = 20,
                                 max_ipq = 0.2,
                                 min_sn = 9,
                                 qcs_to_consider = c("S/N", "IPQ", "Mass accuracy"))

cut_offs <- calculate_cut_offs(summarized_checks,
                               c("Spike PBS", "Total PBS"),
                               3,
                               "Mean")


data_curated <- curate_spectra(checked_data,
                       summarized_checks,
                       cut_offs) 

passing_spectra <- data_curated %>% 
  dplyr::filter(passed_spectra_curation == TRUE)

for_table <- data_curated %>% 
        dplyr::select(1:cut_off_sum_int) %>% 
        dplyr::distinct()



p <- plot_spectra_curation(data_curated, "Yes")

plotly::ggplotly(p, tooltip = "text")

```

## Analyte curation

```{r analyte-curation}

curated_analytes <- curate_analytes(data = passing_spectra,
                                    cut_off_percentage = 25)

analyte_curated_data <- dplyr::left_join(curated_analytes, 
                                         passing_spectra)

plot <- plot_analyte_curation(curated_analytes = curated_analytes,
                              cut_off_percentage = 25,
                              selected_cluster = "IgGI1") 

plotly::ggplotly(plot, tooltip = "text")

dataframe_for_table <- prepare_analyte_curation_table(
  analyte_curated_data = analyte_curated_data,
  selected_cluster = "IgGI1")

charge_columns <- colnames(dataframe_for_table)[-1]

to_check <- dataframe_for_table %>% 
        dplyr::filter(dplyr::if_any(tidyselect::all_of(charge_columns),
                                    ~ .x == "Yes")) %>% 
        dplyr::pull(analyte)
      
to_check_indices <- which(dataframe_for_table$analyte %in% to_check)

ids_to_check <- sapply(paste0("checkbox", charge_columns), 
                       paste0,
                       to_check_indices) %>% 
  c()

dataframe_for_table

charge_columns <- colnames(dataframe_for_table)[-1]

analytes_to_include <- rlang::set_names(charge_columns) %>% 
  purrr::map_dfc(.,
                 function(charge_column) {
                   print(charge_column)
                   ifelse(dataframe_for_table[[charge_column]] == "Yes",
                          dataframe_for_table$analyte,
                          NA)
                 }) %>% 
  tidyr::pivot_longer(
    tidyselect::everything(),
    names_to = "charge",
    values_to = "analyte"
  ) %>% 
  dplyr::filter(!is.na(analyte)) %>% 
  dplyr::mutate(dplyr::across(analyte, as.character))

data_for_norm <- dplyr::left_join(analytes_to_include,
                                  data_curated)

# Maybe a plot (faceted by charge) with for each failed analyte the proportion
# of failed analyte QC's?

to_plot <- analyte_curated_data %>% 
  dplyr::filter(passed_curation == FALSE)

ggplot2::ggplot(to_plot,
                ggplot2::aes(x = analyte,
                    fill = failed_criteria)) +
  ggplot2::geom_bar(position = "fill") +
  ggplot2::scale_y_continuous(labels = function(x) paste0(x * 100, "%"), 
                              name = "Proportion of spectra (%)") +
  #ggplot2::scale_fill_manual() +
  ggplot2::theme_classic() +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
                 strip.background = ggplot2::element_rect(fill = "#F6F6F8"),
                 panel.border = ggplot2::element_rect(colour = "black", fill=NA, size=0.5))
  
for_upset <- to_plot %>% 
  tidyr::extract(failed_criteria,
                 into = c("mass_acc_failed"),
                 regex = ".*(mass accuracy).*",
                 remove = FALSE) %>% 
  tidyr::extract(failed_criteria,
                 into = "IPQ_failed",
                 regex = ".*(IPQ).*",
                 remove = FALSE) %>% 
  tidyr::extract(failed_criteria,
                 into = "SN_failed",
                 regex = ".*(S/N).*",
                 remove = FALSE) %>% 
  dplyr::mutate(across(c(mass_acc_failed,
                         IPQ_failed,
                         SN_failed),
                       ~ !is.na(.x))) %>% 
  dplyr::ungroup() %>% 
  dplyr::mutate(specific_total = group,
                .keep = "unused") %>% 
  dplyr::group_split(analyte, charge)

# purrr::map(for_upset,
#            ~ my_upset(.x) %>% 
#              ggpubr::ggpar(., title = paste(unique(.x$analyte), unique(.x$charge))))
# 
# my_upset <- function(my_data) {
#   ComplexUpset::upset(my_data,
#                     intersect = c("mass_acc_failed", "IPQ_failed", "SN_failed"),
#                     base_annotations = list(
#                       "Sample types" = list(
#                         aes = ggplot2::aes(x = intersection,
#                                      fill = sample_type),
#                         geom = list(ggplot2::geom_bar(stat = "count", position = "stack"))
#                       )
#                     ),
#                     set_sizes = (
#                       upset_set_size(
#                         geom = ggplot2::geom_bar(
#                           ggplot2::aes(fill = sample_type, x = group),
#                           width = 0.8
#                         ),
#                         position='right'
#                       )
#                     )
#   )
# }
# 
# my_venn <- function(my_data) {
#   
# }


```

```{r normalization}

total_intensities <- calculate_total_intensity(data = data_for_norm)
normalized_data <- normalize_data(data = total_intensities) 
normalized_data_wide <- normalized_data %>% 
        # removing columns with values that differ between clusters:
        dplyr::select(-tidyselect::any_of(c("passing_proportion", 
                                            "cut_off_prop", 
                                            "cut_off_sum_int",
                                            "failed_criteria"))) %>% 
        tidyr::pivot_wider(names_from = c(cluster, analyte),
                           names_sep = "_",
                           values_from = relative_abundance)

#normalized_data_wide <- normalized_data_wide %>% dplyr::select(-group)

menu <- normalized_data %>% 
  dplyr::select(tidyselect::any_of(c("sample_name", "group", "sample_id"))) %>%
  dplyr::distinct() %>%
  dplyr::group_by(dplyr::across(tidyselect::any_of("group"))) %>% 
  dplyr::add_count(sample_id, name = "number_of_replicates_after_curation") %>% 
  dplyr::mutate(number_of_replicates_after_curation = ifelse(sample_id == "empty cell in plate design",
                                              1,
                                              number_of_replicates_after_curation)) %>% 
  dplyr::mutate(replicates_after_curation = number_of_replicates_after_curation > 1) %>% 
  dplyr::distinct(dplyr::across(tidyselect::any_of(c("group", "sample_id")))) %>% 
  purrr::pmap_chr(.,
                  paste)

selected_sample_id <- stringr::str_extract(menu[2],
                                             unique(normalized_data$sample_id)) %>% 
  na.omit()

if ("group" %in% colnames(normalized_data)) {
  selected_group <- stringr::str_extract(
    string = menu[2],
    pattern = unique(normalized_data$group)) %>% 
    na.omit(.)
} else {
  selected_group <- NULL
}

repeatability <- calculate_repeatability_stats(normalized_data,
                                               selected_sample_id,
                                               selected_group)

dodged_barplot <- visualize_repeatability_dogded_bars(normalized_data,
                                    selected_sample_id,
                                    selected_group)

mean_barplot <- visualize_repeatability_mean_bars(normalized_data,
                                    selected_sample_id,
                                    selected_group)

plotly::ggplotly(dodged_barplot, tooltip = "text")
plotly::ggplotly(mean_barplot, tooltip = "text")

        
plot <- visualize_repeatability2(repeatability)

pl <- plotly::ggplotly(plot, tooltip = "text")

pl <- change_axis_title_distance(pl, y_distance = 90)

pl

```

```{r exploration, eval=FALSE}

derived_traits <- calculate_derived_traits(normalized_data, c("Fucosylation", "Sialylation", "Bisection", "Galactosylation"))

formulas <- derived_traits %>% 
  dplyr::ungroup() %>% 
  dplyr::select(tidyselect::ends_with("formula")) %>% 
  dplyr::distinct() %>% 
  tidyr::pivot_longer(cols = tidyselect::everything(),
                      names_to = "Derived trait",
                      values_to = "Formula") %>% 
  dplyr::mutate(`Derived trait` = dplyr::recode(`Derived trait`,
                                                fuc_formula = "Fucosylation",
                                                gal_formula = "Galactosylation",
                                                sial_formula = "Sialylation",
                                                bis_formula = "Bisection"))

DT::datatable(formulas, rownames = FALSE, options = list(paging = FALSE,
                                                         ordering = FALSE,
                                                         searching = FALSE))
      
data_with_derived_traits <- dplyr::full_join(
  normalized_data_wide,
  derived_traits %>% dplyr::select(-tidyselect::ends_with("formula"))) %>% 
  tidyr::pivot_wider(names_from = cluster,
                     values_from = dplyr::any_of(c("Fucosylation",
                                                   "Galactosylation",
                                                   "Bisection",
                                                   "Sialylation")),
                     names_glue = "{cluster}_{.value}")

pl <- my_boxplot(data_with_derived_traits, 
                 "sample_type", 
                 "IgGI1_Fucosylation", 
                 facets = c("group", "sample_type")) 

pl <- my_histogram(data_with_derived_traits,
                   "IgGI1_Fucosylation",
                   color = "sample_type")

boxplot_traces <- 1:nfacets(pl)

plotly::ggplotly(pl, tooltip = "text") #%>% 
  plotly::style(hoverinfo = "y", traces = boxplot_traces) %>% 
  hide_outliers(.)





```

