---
title: "Glycodash data import"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{glycodash_data_import}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include=FALSE}
# package is not installed yet so instead of:
#library(glycodash)

# I'm using:
devtools::load_all()
# to make the package functions available in this .Rmd file
```

## Introduction

The data-import functions can be used to convert a LacyTools summary file to a format suitable for R. In addition, metadata ca be added if a metadata file and a platedesign file are available.

```{r load-data}

lacytools_file <- system.file("extdata", "LacyTools_summary.txt", package = "glycodash")

groups_file <- system.file("extdata", "groups.rds", package = "glycodash")
load(groups_file)

plate_design <- dplyr::left_join(plate_design, groups, by = "sample_id")

# save(groups, file = "groups.rds")

data <- read_lacytools_summary(lacytools_file)

# Reading in the platedesign from an Excel file, writing the platedesign 
# into a .csv file (because this is required for the read_plate() function from plater) 
# and reading the plates using the read_plate() function from the plater package.
# I want users to upload an Excel file and not a .csv file, because if the csv file
# is delimited with ";" instead of "," the read_plate() function no longer works.
# If a user would have to save an Excel file as a .csv file manually, it cannot be 
# guaranteed that the right delimiter would be used.

read_plate_design <- function(plate_design_file) {
  
  plate_design <- readxl::read_excel(plate_design_file)
  path_to_platedesign_csv <- file.path(tempdir(), "glycodash_platedesign.csv")
  readr::write_csv(plate_design, file = path_to_platedesign_csv)
  plate_design <- plater::read_plate(file = path_to_platedesign_csv, 
                                     well_ids_column = "well")
  return(plate_design)
}

# Processing the plate_design dataframe (pivoting to a long format and adding
# a plate_well column)
# Exclude the sample_type part since this could be different for different data?

# Make this into a process plate_design function

plate_design_file <- system.file("extdata",
                                 "plate_design.xlsx",
                                 package = "glycodash")

process_plate_design <- function (plate_design) {
  plate_design <- plate_design %>%
  tidyr::pivot_longer(cols = -well,
                      names_to = "plate",
                      values_to = "sample_id") %>%
    dplyr::mutate(plate = stringr::str_extract(plate, "\\d+"),
                  well = stringr::str_extract(well, "[A-H]\\d{1,2}"),
                  plate_well = paste(plate, well, sep = "_")) %>% 
    dplyr::arrange(plate_well) %>% 
    dplyr::select(-c(plate, well)) %>% 
    tidyr::extract(col = sample_id, 
                   into = c("sample_type"), 
                   regex = "([[:alpha:]]+)",
                   remove = FALSE)
  
  plate_design <- handle_duplicates(plate_design)
  
  return(plate_design)
}

# Show automatically determined groups and ask user if they want to edit them

# Ask Tamas whether plate_design files always look like this and whether duplicates
# are always handled in this way.
handle_duplicates <- function(plate_design) {
  new_sample_ids <- vector()
  new_sample_types <- vector()
  duplicate <- vector()
  for (i in 1:length(plate_design$sample_id)) {
    if (i == 1 & plate_design$sample_id[i] == "duplicate") {
      stop(print("Error: first sample is a duplicate."))
      }
    if (plate_design$sample_id[i] == "duplicate") {
      new_sample_ids[i] <- plate_design$sample_id[i-1]
      new_sample_types[i] <- plate_design$sample_type[i-1]
      duplicate[i] <- TRUE
      } else {
        new_sample_ids[i] <- plate_design$sample_id[i]
        new_sample_types[i] <- plate_design$sample_type[i]
        duplicate[i] <- FALSE
    }
  }
  new_plate_design <- plate_design %>% 
    dplyr::mutate(sample_id = new_sample_ids,
                  sample_type = new_sample_types,
                  duplicate = duplicate)
  return(new_plate_design)
}

read_and_process_plate_design <- function(plate_design_file) {
  plate_design <- read_plate_design(plate_design_file)
  plate_design <- process_plate_design(plate_design)
  return(plate_design)
}

plate_design2 <- read_and_process_plate_design(plate_design_file)
plate_design2 <- plate_design2 %>% 
  dplyr::select(-sample_type)
b <- dplyr::full_join(groups, plate_design2)
b <- unique(b)

# make a read metadata function, choose date columns and sample_id column?

date_with_text <- function(date_text_values, origin = "1899-12-30"){
  no_nas <- date_text_values[!is.na(date_text_values)]
  test <- suppressWarnings(as.numeric(no_nas))
  num <- suppressWarnings(as.numeric(date_text_values))
  dates <- as.Date(num, origin = origin)
  if(anyNA(test)){
    dates <- as.character(dates)
    dates[is.na(num)] <- as.character(date_text_values[is.na(num)])
    message(paste("Some date entries in", 
                  dplyr::cur_column(), 
                  "contain text. Output will have class character."))
  }
  return(dates)
}

read_metadata <- function (metadata_file, sample_id_column) {
  metadata <- readxl::read_excel(metadata_file,
                               col_types = "text", 
                               na = c("", "NA"))
  metadata <- metadata %>% 
    dplyr::rename_with(.cols = tidyselect::everything(), 
                       .fn = snakecase::to_snake_case) 
}

metadata_file <- system.file("extdata",
                             "Metadata.xlsx",
                             package = "glycodash")

date_cols <- c("start_of_symptoms", "collection_date")
metadata <- read_metadata(metadata_file)
metadata <- metadata %>% 
  dplyr::mutate(across(date_cols, date_with_text)) %>% 
  dplyr::rename(sample_id = id_on_sample_tube)

link_metadata_to_platedesign <- function(plate_design, metadata) {
  no_match <- check_matches(plate_design, metadata)
  metadata_left <- dplyr::left_join(plate_design, metadata, by = "sample_id")
  return(list(metadata_left, no_match))
}

check_sample_id_matches <- function (plate_design, metadata) {
  # no_match are the sample_ids that are present in the plate_design,
  # but missing in the metadata
  no_match <- setdiff(plate_design$sample_id, metadata$sample_id)
  if (!rlang::is_empty(no_match)) {
    warning(paste(length(no_match),
                  "sample_ids in platedesign don't have a match in the metadata.",
                  "The unmatched sample_ids can be found in the vector \"no_match\"."))
    return(no_match)
  } else {
    message("All sample_ids in platedesign have a match in the metadata.")
  }
}

data <- dplyr::left_join(data, b)

a <- suppressWarnings(check_sample_id_matches(data, metadata))

empty_data <- data.frame("group" = c("", "", ""),
                         "pattern" = c("", "", ""))

DT::datatable(empty_data)

```

