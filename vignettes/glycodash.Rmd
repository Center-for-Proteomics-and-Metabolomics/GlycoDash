---
title: "glycodash"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{glycodash}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}

#library(glycodash)
devtools::load_all()

```

This vignette is not yet finished!

## Data import

The data import functions can be used to convert a LacyTools summary file to a format suitable for R.

```{r reading-the-lacytools-summary}

lacytools_file <- system.file("extdata",
                              "LacyTools_summary_example.txt", 
                              package = "glycodash")

raw_data <- read_non_rectangular(lacytools_file)

data <- convert_lacytools_summary(raw_data) %>% 
  detect_group(.,
               keyword_specific = "Spike",
               keyword_total = "Total") %>% 
  # This might be a faster way of adding clusters since now a factor is used
  dplyr::mutate(analyte = factor(analyte))

cluster_keywords <- c("IgGI1")

# The str_extract is now only done on each unique analyte instead of on every single one
clusters <- tibble::tibble(analyte = levels(data$analyte)) %>% 
  dplyr::mutate(cluster = stringr::str_extract(analyte,
                     paste0("(",
                            paste0(cluster_keywords, 
                                   collapse = "|"),
                            ")")))

data <- dplyr::left_join(data, clusters) %>% 
  dplyr::relocate(cluster, .after = analyte)

```

In addition, a plate design file can be processed to add sample types and sample ID's to the data.

```{r processing-the-plate-design}

# plate_design_file <- system.file("extdata",
#                                  "Plate_design_example.xlsx",
#                                  package = "glycodash")

sample_list_file <- system.file("extdata",
                                 "Sample_list_example.xlsx",
                                 package = "glycodash")

sample_list <- process_sample_list(sample_list_file)

data_complete <- dplyr::left_join(data,
                                    sample_list) %>% 
  tidyr::extract(col = sample_id,
                 into = c("sample_type"),
                 regex = "([[:alpha:]]+)",
                 remove = FALSE)

# No longer works with stricter sample name format (sample list should be used instead):
#plate_design <- read_and_process_plate_design(plate_design_file)

#data_with_platewell <- detect_plate_and_well(data)

# data_complete <- dplyr::left_join(data_with_platewell,
#                                   plate_design) %>% 
#   tidyr::extract(col = sample_id,
#                  into = c("sample_type"),
#                  regex = "([[:alpha:]]+)",
#                  remove = FALSE) %>% 
#   define_clusters(.,
#                   cluster_keywords = "IgGI1")

replicates <- data_complete %>% 
        dplyr::select(tidyselect::any_of(c("sample_name", "sample_id", "group"))) %>% 
        dplyr::distinct() %>% 
        dplyr::group_by(dplyr::across(tidyselect::any_of("group"))) %>% 
        dplyr::add_count(sample_id, name = "number_of_replicates") %>% 
        dplyr::mutate(number_of_replicates = ifelse(sample_id == "empty cell in plate design",
                                                    1,
                                                    number_of_replicates)) %>% 
        dplyr::mutate(replicates = ifelse(number_of_replicates > 1, 
                                          TRUE, 
                                          FALSE))
      
data_complete <- dplyr::full_join(replicates, data_complete) %>% 
  dplyr::ungroup(.)

data_complete

```

Finally, metadata can be added to the data.

```{r adding-metadata, eval=FALSE}

metadata_file <- system.file("extdata",
                            "Metadata_example.xlsx",
                            package = "glycodash")

metadata <- read_metadata(metadata_file,
                          "Metadata_example.xlsx")

metadata

data <- dplyr::left_join(data_complete,
                         metadata$Metadata_example.xlsx,
                         by = c(sample_id = "sample_id"))

```

## Spectra curation

The spectra curation functions can be used to curate spectra, based on the 
proportion of analytes within the spectrum that fulfill the analyte quality 
criteria and based on the sum intensity of those passing analytes within the 
spectrum. This proportion of passing analytes and this sum intensity are compared
to the cut-off values for both. The cut-off values are the average 
proportion of passing analytes and average sum intensity + 3 times the standard 
deviations in a chosen group of spectra that should not pass curation (cut_off_basis). 

```{r spectra-curation-uncalibrated-as-NA}

min_ppm_deviation = -20
max_ppm_deviation = 20
max_ipq = 0.2
min_sn = 9
criteria_to_consider <- c("Mass accuracy", "IPQ", "S/N")
uncalibrated_as_NA <- FALSE

checked_data <- check_analyte_quality_criteria(data_complete,
                                               min_ppm_deviation,
                                               max_ppm_deviation,
                                               max_ipq,
                                               min_sn,
                                               criteria_to_consider,
                                               uncalibrated_as_NA)

summarized_checks <- summarize_spectra_checks(checked_data)

group_keyword = NULL
control_sample_types = c("PBS", "Visucon")
percentile = 95
use_mean_SD = TRUE
SD_factor = 3


cut_off_basis <- summarized_checks %>% 
  dplyr::filter(if (!is.null(group_keyword)) group == group_keyword else TRUE) %>% 
  dplyr::filter(if (!is.null(control_sample_types)) sample_type %in% control_sample_types else TRUE)

grouping_variables <- c("group", "cluster")

cut_offs <- cut_off_basis %>%  
  dplyr::group_by(dplyr::across(tidyselect::any_of(grouping_variables))) %>% 
  dplyr::summarise(
    cut_off_sum_int = if (use_mean_SD) { 
      mean_plus_SD(sum_intensity, SD_factor, uncalibrated_as_NA) } else { 
        quantile(sum_intensity, 
                 probs = percentile / 100,
                 names = FALSE,
                 na.rm = uncalibrated_as_NA) },
    cut_off_prop = quantile(passing_proportion, 
                            probs = percentile / 100,
                            names = FALSE,
                            na.rm = uncalibrated_as_NA),
    sample_type = unique(sample_type),
    type = "based_on_negative_controls") %>% 
  #dplyr::mutate(type = "based_on_negative_controls") %>% 
  #dplyr::distinct() %>% 
  # dplyr::select(tidyselect::any_of(c("cluster",
  #                                    "sample_type",
  #                                    "group",
  #                                    "cut_off_prop",
  #                                    "cut_off_sum_int",
  #                                    "type"))) %>%
  tidyr::nest(., "sample_type_list" = sample_type)

cut_offs_specific3 <- calculate_cut_offs_with_percentile(summarized_checks,
                                                         control_sample_types = c("PBS", "Visucon"),
                                                         group_keyword = "Spike",
                                                         percentile = 95,
                                                         use_mean_SD = TRUE,
                                                         SD_factor = 3,
                                                         na.rm = FALSE)

data_checked <- data_complete %>% 
  check_each_criterium(., 
                       min_ppm_deviation,
                       max_ppm_deviation,
                       max_ipq,
                       min_sn) %>% 
  apply_chosen_criteria(.,
                        criteria_to_consider,
                        uncalibrated_as_NA = uncalibrated_as_NA) %>%
  report_failed_criteria(.,
                         criteria_to_consider) 

# Can't reuse same criteria_check column for analyte_curation because here only
# qcs to consider are taken into account!

grouping_variables <- c("group", "sample_type", "cluster", "sample_name", "sample_id")
  
summarized_checks <- data_checked %>% 
  # I'm using across() and any_of() because if the data is not Ig data, the
  # column "group" doesn't exist:
  dplyr::group_by(dplyr::across(tidyselect::any_of(grouping_variables))) %>% 
  dplyr::summarise(passing_proportion = sum(criteria_check#,
                                            #na.rm = TRUE if NAs are removed they wont propogate
  )/dplyr::n(), 
  sum_intensity = sum(absolute_intensity_background_subtracted[criteria_check == TRUE]#,
                      #na.rm = TRUE
  )) %>% 
  dplyr::ungroup(.)

grouping_variables <- c("group", "sample_type", "cluster", "sample_name", "sample_id")
  
  summarized_checks <- data_checked %>% 
    # I'm using across() and any_of() because if the data is not Ig data, the
    # column "group" doesn't exist:
    dplyr::group_by(dplyr::across(tidyselect::any_of(grouping_variables))) %>% 
    dplyr::summarise(passing_proportion = sum(analyte_meets_criteria)/dplyr::n(), 
                     sum_intensity = sum(
                       absolute_intensity_background_subtracted[analyte_meets_criteria == TRUE]
                     )) %>% 
    dplyr::ungroup(.)


p <- create_cut_off_plot(summarized_checks)

plotly::ggplotly(p, tooltip = "text")

cut_offs <- calculate_cut_offs_with_percentile(summarized_checks = summarized_checks,
                                               percentile = 95,
                                               na.rm = TRUE,
                                               negative_control_sample_types = "PBS")

summarized_checks_with_cut_offs <- dplyr::left_join(summarized_checks, 
                                                    cut_offs) %>% 
  dplyr::select(-tidyselect::any_of(c("type", 
                                      "sample_type_list"))) %>% 
  dplyr::ungroup(.)

p_cut_offs <- p +
          ggplot2::geom_vline(data = summarized_checks_with_cut_offs,
                              ggplot2::aes(xintercept = cut_off_prop,
                                           text = paste0("Passing proportion cut-off: ",
                                                         cut_off_prop)),
                              linetype = "dotted") +
          ggplot2::geom_hline(data = summarized_checks_with_cut_offs,
                              ggplot2::aes(yintercept = cut_off_sum_int,
                                           text = paste0("Sum intensity cut-off: ",
                                                         cut_off_sum_int)),
                              linetype = "dotted")

plotly::ggplotly(p_cut_offs, tooltip = "text")

determine_reason_for_failure <- function(data) {
  data %>% 
    dplyr::mutate(reason_for_failure = dplyr::na_if(
                  dplyr::case_when(
                  passing_proportion <= cut_off_prop & sum_intensity <= cut_off_sum_int ~ "Proportion of passing analytes and sum intensity below cut-offs",
                  passing_proportion <= cut_off_prop ~ "Proportion of passing analytes below cut-off",
                  sum_intensity <= cut_off_sum_int ~ "Sum intensity below cut-off",
                  is.na(has_passed_spectra_curation) ~ "Empty line in LacyTools summary file",
                  TRUE ~ "" # will be replaced with NA
                ),
                ""))
}

passing_spectra <- summarized_checks_with_cut_offs %>%
  # Can't use all() instead of & because all() is not vectorized
  dplyr::mutate(has_passed_spectra_curation = passing_proportion > cut_off_prop &
                  sum_intensity > cut_off_sum_int) %>% 
  determine_reason_for_failure()
  

curated_data <- dplyr::full_join(passing_spectra, 
                                 data_checked) %>% 
    dplyr::relocate(c(has_passed_spectra_curation, reason_for_failure), 
                    .after = sample_name) %>% 
    dplyr::relocate(c(criteria_check,
                      failed_criteria),
                    .after = charge) %>% 
    dplyr::relocate(tidyselect::any_of(c("sample_id", "plate_well")),
                    .after = sample_name)

passing_spectra_data <- curated_data %>% 
  dplyr::filter(has_passed_spectra_curation == TRUE)


# zeros we see here are because all analytes failed the criteria_check,
# not because of failed calibration

```

```{r spectra-curation-uncalibrated-as-zero}

min_ppm_deviation = -20
max_ppm_deviation = 20
max_ipq = 0.2
min_sn = 9
qcs <- c("IPQ", "S/N", "Mass accuracy")

# Can't reuse same criteria_check column for analyte_curation because here only
# qcs to consider are taken into account!

data_checked <- data_complete %>% 
    dplyr::mutate(`Mass accuracy` = dplyr::between(mass_accuracy_ppm, 
                                            min_ppm_deviation, 
                                            max_ppm_deviation),
                  IPQ = isotopic_pattern_quality < max_ipq,
                  `S/N` = sn > min_sn) %>% 
    # rowwise() allows you to check all the criteria in qcs using c_across per row:
    dplyr::rowwise() %>% 
    dplyr::mutate(criteria_check = all(dplyr::c_across(tidyselect::all_of(qcs))) %>% 
                    tidyr::replace_na(., FALSE)
                  # If we leave in NA's this means that there are less samples 
                  # to base the cut-offs on, since uncalibrated spectra are no
                  # longer interpreted as 0 but instead left out
                    ) %>% 
    tidyr::pivot_longer(cols = c(`Mass accuracy`, IPQ, `S/N`),
                        names_to = "criterium",
                        values_to = "passed") %>% 
    dplyr::mutate(failed_criteria = ifelse(passed == FALSE, criterium, NA)) %>% 
    dplyr::select(-c(criterium, passed)) %>% 
    dplyr::group_by(sample_name, analyte, charge) %>% 
      dplyr::summarise(failed_criteria = dplyr::if_else(
        all(is.na(failed_criteria)),
        "none",
        comma_and(unique(failed_criteria[!is.na(failed_criteria)]))),
        across()) %>% 
      dplyr::distinct() %>% 
  dplyr::relocate(failed_criteria,
                  .after = criteria_check)

grouping_variables <- c("group", "sample_type", "cluster", "sample_name", "sample_id")
  
summarized_checks <- data_checked %>% 
  # I'm using across() and any_of() because if the data is not Ig data, the
  # column "group" doesn't exist:
  dplyr::group_by(dplyr::across(tidyselect::any_of(grouping_variables))) %>% 
  dplyr::summarise(passing_proportion = sum(criteria_check,
                                            na.rm = TRUE)/dplyr::n(), 
  sum_intensity = sum(absolute_intensity_background_subtracted[criteria_check == TRUE],
                      na.rm = TRUE)) %>% 
  dplyr::ungroup(.)


p <- create_cut_off_plot(summarized_checks)

plotly::ggplotly(p, tooltip = "text")

cut_offs <- calculate_cut_offs_with_percentile(summarized_checks = summarized_checks,
                                               percentile = 95,
                                               na.rm = FALSE,
                                               negative_control_sample_types = "PBS")

summarized_checks_with_cut_offs <- dplyr::left_join(summarized_checks, 
                                                    cut_offs) %>% 
  dplyr::select(-tidyselect::any_of(c("type", 
                                      "sample_type_list"))) %>% 
  dplyr::ungroup(.)

p_cut_offs <- p +
          ggplot2::geom_vline(data = summarized_checks_with_cut_offs,
                              ggplot2::aes(xintercept = cut_off_prop,
                                           text = paste0("Passing proportion cut-off: ",
                                                         cut_off_prop)),
                              linetype = "dotted") +
          ggplot2::geom_hline(data = summarized_checks_with_cut_offs,
                              ggplot2::aes(yintercept = cut_off_sum_int,
                                           text = paste0("Sum intensity cut-off: ",
                                                         cut_off_sum_int)),
                              linetype = "dotted")

plotly::ggplotly(p_cut_offs, tooltip = "text")

determine_reason_for_failure <- function(data) {
  data %>% 
    dplyr::mutate(reason_for_failure = dplyr::na_if(
                  dplyr::case_when(
                  passing_proportion <= cut_off_prop & sum_intensity <= cut_off_sum_int ~ "Proportion of passing analytes and sum intensity below cut-offs",
                  passing_proportion <= cut_off_prop ~ "Proportion of passing analytes below cut-off",
                  sum_intensity <= cut_off_sum_int ~ "Sum intensity below cut-off",
                  is.na(has_passed_spectra_curation) ~ "Empty line in LacyTools summary file",
                  TRUE ~ "" # will be replaced with NA
                ),
                ""))
}

passing_spectra <- summarized_checks_with_cut_offs %>%
  # Can't use all() instead of & because all() is not vectorized
  dplyr::mutate(has_passed_spectra_curation = passing_proportion > cut_off_prop &
                  sum_intensity > cut_off_sum_int) %>% 
  determine_reason_for_failure()
  

curated_data <- dplyr::full_join(passing_spectra, 
                                 data_checked) %>% 
    dplyr::relocate(c(has_passed_spectra_curation, reason_for_failure), 
                    .after = sample_name) %>% 
    dplyr::relocate(c(criteria_check,
                      failed_criteria),
                    .after = charge) %>% 
    dplyr::relocate(tidyselect::any_of(c("sample_id", "plate_well")),
                    .after = sample_name)

passing_spectra_data <- curated_data %>% 
  dplyr::filter(has_passed_spectra_curation == TRUE)


```


## Analyte curation

```{r analyte-curation}

curated_analytes <- curate_analytes(data = passing_spectra,
                                    cut_off_percentage = 25,
                                    bio_group = "sample_type")

analyte_curated_data <- dplyr::left_join(curated_analytes, 
                                         passing_spectra)

plot <- plot_analyte_curation(curated_analytes = curated_analytes,
                              cut_off_percentage = 25,
                              selected_cluster = "IgGI1") 

plotly::ggplotly(plot, tooltip = "text")

dataframe_for_table <- prepare_analyte_curation_table(
  analyte_curated_data = analyte_curated_data,
  selected_cluster = "IgGI1")

charge_columns <- colnames(dataframe_for_table)[-1]

to_check <- dataframe_for_table %>% 
        dplyr::filter(dplyr::if_any(tidyselect::all_of(charge_columns),
                                    ~ .x == "Yes")) %>% 
        dplyr::pull(analyte)
      
to_check_indices <- which(dataframe_for_table$analyte %in% to_check)

ids_to_check <- sapply(paste0("checkbox", charge_columns), 
                       paste0,
                       to_check_indices) %>% 
  c()

dataframe_for_table

charge_columns <- colnames(dataframe_for_table)[-1]

analytes_to_include <- rlang::set_names(charge_columns) %>% 
  purrr::map_dfc(.,
                 function(charge_column) {
                   print(charge_column)
                   ifelse(dataframe_for_table[[charge_column]] == "Yes",
                          dataframe_for_table$analyte,
                          NA)
                 }) %>% 
  tidyr::pivot_longer(
    tidyselect::everything(),
    names_to = "charge",
    values_to = "analyte"
  ) %>% 
  dplyr::filter(!is.na(analyte)) %>% 
  dplyr::mutate(dplyr::across(analyte, as.character))

data_for_norm <- dplyr::left_join(analytes_to_include,
                                  data_curated)

# Maybe a plot (faceted by charge) with for each failed analyte the proportion
# of failed analyte QC's?

to_plot <- analyte_curated_data %>% 
  dplyr::filter(passed_curation == FALSE)

ggplot2::ggplot(to_plot,
                ggplot2::aes(x = analyte,
                    fill = failed_criteria)) +
  ggplot2::geom_bar(position = "fill") +
  ggplot2::scale_y_continuous(labels = function(x) paste0(x * 100, "%"), 
                              name = "Proportion of spectra (%)") +
  #ggplot2::scale_fill_manual() +
  ggplot2::theme_classic() +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
                 strip.background = ggplot2::element_rect(fill = "#F6F6F8"),
                 panel.border = ggplot2::element_rect(colour = "black", fill=NA, size=0.5))
  
for_upset <- to_plot %>% 
  tidyr::extract(failed_criteria,
                 into = c("mass_acc_failed"),
                 regex = ".*(mass accuracy).*",
                 remove = FALSE) %>% 
  tidyr::extract(failed_criteria,
                 into = "IPQ_failed",
                 regex = ".*(IPQ).*",
                 remove = FALSE) %>% 
  tidyr::extract(failed_criteria,
                 into = "SN_failed",
                 regex = ".*(S/N).*",
                 remove = FALSE) %>% 
  dplyr::mutate(across(c(mass_acc_failed,
                         IPQ_failed,
                         SN_failed),
                       ~ !is.na(.x))) %>% 
  dplyr::ungroup() %>% 
  dplyr::mutate(specific_total = group,
                .keep = "unused") %>% 
  dplyr::group_split(analyte, charge)

# purrr::map(for_upset,
#            ~ my_upset(.x) %>% 
#              ggpubr::ggpar(., title = paste(unique(.x$analyte), unique(.x$charge))))
# 
# my_upset <- function(my_data) {
#   ComplexUpset::upset(my_data,
#                     intersect = c("mass_acc_failed", "IPQ_failed", "SN_failed"),
#                     base_annotations = list(
#                       "Sample types" = list(
#                         aes = ggplot2::aes(x = intersection,
#                                      fill = sample_type),
#                         geom = list(ggplot2::geom_bar(stat = "count", position = "stack"))
#                       )
#                     ),
#                     set_sizes = (
#                       upset_set_size(
#                         geom = ggplot2::geom_bar(
#                           ggplot2::aes(fill = sample_type, x = group),
#                           width = 0.8
#                         ),
#                         position='right'
#                       )
#                     )
#   )
# }
# 
# my_venn <- function(my_data) {
#   
# }


```

```{r normalization}

total_intensities <- calculate_total_intensity(data = data_for_norm)
normalized_data <- normalize_data(data = total_intensities) 
normalized_data_wide <- normalized_data %>% 
        # removing columns with values that differ between clusters:
        dplyr::select(-tidyselect::any_of(c("passing_proportion", 
                                            "cut_off_prop", 
                                            "cut_off_sum_int",
                                            "failed_criteria"))) %>% 
        tidyr::pivot_wider(names_from = c(cluster, analyte),
                           names_sep = "_",
                           values_from = relative_abundance)

#normalized_data_wide <- normalized_data_wide %>% dplyr::select(-group)

menu <- normalized_data %>% 
  dplyr::select(tidyselect::any_of(c("sample_name", "group", "sample_id"))) %>%
  dplyr::distinct() %>%
  dplyr::group_by(dplyr::across(tidyselect::any_of("group"))) %>% 
  dplyr::add_count(sample_id, name = "number_of_replicates_after_curation") %>% 
  dplyr::mutate(number_of_replicates_after_curation = ifelse(sample_id == "empty cell in plate design",
                                              1,
                                              number_of_replicates_after_curation)) %>% 
  dplyr::mutate(replicates_after_curation = number_of_replicates_after_curation > 1) %>% 
  dplyr::distinct(dplyr::across(tidyselect::any_of(c("group", "sample_id")))) %>% 
  purrr::pmap_chr(.,
                  paste)

selected_sample_id <- stringr::str_extract(menu[2],
                                             unique(normalized_data$sample_id)) %>% 
  na.omit()

if ("group" %in% colnames(normalized_data)) {
  selected_group <- stringr::str_extract(
    string = menu[2],
    pattern = unique(normalized_data$group)) %>% 
    na.omit(.)
} else {
  selected_group <- NULL
}

repeatability <- calculate_repeatability_stats(normalized_data,
                                               selected_sample_id,
                                               selected_group)

dodged_barplot <- visualize_repeatability_dogded_bars(normalized_data,
                                    selected_sample_id,
                                    selected_group)

mean_barplot <- visualize_repeatability_mean_bars(normalized_data,
                                    selected_sample_id,
                                    selected_group)

plotly::ggplotly(dodged_barplot, tooltip = "text")
plotly::ggplotly(mean_barplot, tooltip = "text")

        
plot <- visualize_repeatability2(repeatability)

pl <- plotly::ggplotly(plot, tooltip = "text")

pl <- change_axis_title_distance(pl, y_distance = 90)

pl

```

```{r exploration, eval=FALSE}

derived_traits <- calculate_derived_traits(normalized_data, c("Fucosylation", "Sialylation", "Bisection", "Galactosylation"))

formulas <- derived_traits %>% 
  dplyr::ungroup() %>% 
  dplyr::select(tidyselect::ends_with("formula")) %>% 
  dplyr::distinct() %>% 
  tidyr::pivot_longer(cols = tidyselect::everything(),
                      names_to = "Derived trait",
                      values_to = "Formula") %>% 
  dplyr::mutate(`Derived trait` = dplyr::recode(`Derived trait`,
                                                fuc_formula = "Fucosylation",
                                                gal_formula = "Galactosylation",
                                                sial_formula = "Sialylation",
                                                bis_formula = "Bisection"))

DT::datatable(formulas, rownames = FALSE, options = list(paging = FALSE,
                                                         ordering = FALSE,
                                                         searching = FALSE))
      
data_with_derived_traits <- dplyr::full_join(
  normalized_data_wide,
  derived_traits %>% dplyr::select(-tidyselect::ends_with("formula"))) %>% 
  tidyr::pivot_wider(names_from = cluster,
                     values_from = dplyr::any_of(c("Fucosylation",
                                                   "Galactosylation",
                                                   "Bisection",
                                                   "Sialylation")),
                     names_glue = "{cluster}_{.value}")

pl <- my_boxplot(data_with_derived_traits, 
                 "sample_type", 
                 "IgGI1_Fucosylation", 
                 facets = c("group", "sample_type")) 

pl <- my_histogram(data_with_derived_traits,
                   "IgGI1_Fucosylation",
                   color = "sample_type")

boxplot_traces <- 1:nfacets(pl)

plotly::ggplotly(pl, tooltip = "text") #%>% 
  plotly::style(hoverinfo = "y", traces = boxplot_traces) %>% 
  hide_outliers(.)





```

