---
title: "glycodash"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{glycodash}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}

#library(glycodash)
devtools::load_all()

```

This vignette is not yet finished!

## Data import

The data import functions can be used to convert a LacyTools summary file to a format suitable for R.

```{r reading-the-lacytools-summary}

lacytools_file <- system.file("extdata",
                              "LacyTools_summary_example.txt", 
                              package = "glycodash")

raw_data <- read_non_rectangular(lacytools_file)

data <- convert_lacytools_summary(raw_data) %>% 
  detect_group(.,
               keyword_specific = "Spike",
               keyword_total = "Total") %>% 
  # This might be a faster way of adding clusters since now a factor is used
  dplyr::mutate(analyte = factor(analyte))

cluster_keywords <- c("IgGI1")

# The str_extract is now only done on each unique analyte instead of on every single one
clusters <- tibble::tibble(analyte = levels(data$analyte)) %>% 
  dplyr::mutate(cluster = stringr::str_extract(analyte,
                     paste0("(",
                            paste0(cluster_keywords, 
                                   collapse = "|"),
                            ")")))

data <- dplyr::left_join(data, clusters) %>% 
  dplyr::relocate(cluster, .after = analyte)
  

```

In addition, a plate design file can be processed to add sample types and sample ID's to the data.

```{r processing-the-plate-design}

# plate_design_file <- system.file("extdata",
#                                  "Plate_design_example.xlsx",
#                                  package = "glycodash")

sample_list_file <- system.file("extdata",
                                 "Sample_list_example.xlsx",
                                 package = "glycodash")

sample_list <- process_sample_list(sample_list_file)

data_complete <- dplyr::left_join(data,
                                    sample_list) %>% 
  tidyr::extract(col = sample_id,
                 into = c("sample_type"),
                 regex = "([[:alpha:]]+)",
                 remove = FALSE)

# No longer works with stricter sample name format (sample list should be used instead):
#plate_design <- read_and_process_plate_design(plate_design_file)

#data_with_platewell <- detect_plate_and_well(data)

# data_complete <- dplyr::left_join(data_with_platewell,
#                                   plate_design) %>% 
#   tidyr::extract(col = sample_id,
#                  into = c("sample_type"),
#                  regex = "([[:alpha:]]+)",
#                  remove = FALSE) %>% 
#   define_clusters(.,
#                   cluster_keywords = "IgGI1")

replicates <- data_complete %>% 
        dplyr::select(tidyselect::any_of(c("sample_name", "sample_id", "group"))) %>% 
        dplyr::distinct() %>% 
        dplyr::group_by(dplyr::across(tidyselect::any_of("group"))) %>% 
        dplyr::add_count(sample_id, name = "number_of_replicates") %>% 
        dplyr::mutate(number_of_replicates = ifelse(sample_id == "empty cell in plate design",
                                                    1,
                                                    number_of_replicates)) %>% 
        dplyr::mutate(replicates = ifelse(number_of_replicates > 1, 
                                          TRUE, 
                                          FALSE))
      
data_complete <- dplyr::full_join(replicates, data_complete) %>% 
  dplyr::ungroup(.)

data_complete

```

Finally, metadata can be added to the data.

```{r adding-metadata, eval=FALSE}

metadata_file <- system.file("extdata",
                            "Metadata_example.xlsx",
                            package = "glycodash")

metadata <- read_metadata(metadata_file,
                          "Metadata_example.xlsx")

metadata

data <- dplyr::left_join(data_complete,
                         metadata$Metadata_example.xlsx,
                         by = c(sample_id = "sample_id"))

```

## Spectra curation

The spectra curation functions can be used to curate spectra, based on the 
proportion of analytes within the spectrum that fulfill the analyte quality 
criteria and based on the sum intensity of those passing analytes within the 
spectrum. This proportion of passing analytes and this sum intensity are compared
to the cut-off values for both. The cut-off values are the average 
proportion of passing analytes and average sum intensity + 3 times the standard 
deviations in a chosen group of spectra that should not pass curation (cut_off_basis). 

```{r}

checked_data <- check_analyte_quality_criteria(my_data = data_complete,
                        min_ppm_deviation = -20,
                        max_ppm_deviation = 20,
                        max_ipq = 0.2,
                        min_sn = 9,
                        criteria_to_consider = c("S/N", "IPQ", "Mass accuracy"))

summarized_checks <- summarize_spectra_checks(checked_data)

cut_offs <- calculate_cut_offs(summarized_checks = summarized_checks,
                               #exclude_sample_types = c("PBS", "Visucon", "IVIGg"),
                               percentile = 2,
                               uncalibrated_as_NA = FALSE)

summarized_checks_with_cut_offs <- dplyr::left_join(summarized_checks,
                                                    cut_offs)

pc <- create_cut_off_plot(summarized_checks_with_cut_offs)
pc <- pc +
          ggplot2::geom_vline(data = summarized_checks_with_cut_offs,
                              ggplot2::aes(xintercept = cut_off_passing_analyte_percentage,
                                           text = paste0("Passing analyte percentage cut-off: ",
                                                         cut_off_passing_analyte_percentage)),
                              linetype = "dotted") +
          ggplot2::geom_hline(data = summarized_checks_with_cut_offs,
                              ggplot2::aes(yintercept = cut_off_sum_intensity,
                                           text = paste0("Sum intensity cut-off: ",
                                                         cut_off_sum_intensity)),
                              linetype = "dotted")
plotly::ggplotly(pc, tooltip = "text")

curated_data <- curate_spectra(checked_data = checked_data,
                               summarized_checks = summarized_checks,
                               cut_offs = cut_offs,
                               uncalibrated_as_NA = FALSE)

p <- plot_spectra_curation_results(curated_data = curated_data,
                                   Ig_data = "Yes")

plotly::ggplotly(p, tooltip = "text")


```


```{r spectra-curation-uncalibrated-as-NA}

min_ppm_deviation = -20
max_ppm_deviation = 20
max_ipq = 0.2
min_sn = 9
criteria_to_consider <- c("Mass accuracy", "IPQ", "S/N")
uncalibrated_as_NA <- TRUE

checked_data <- check_analyte_quality_criteria(data_complete,
                                               min_ppm_deviation,
                                               max_ppm_deviation,
                                               max_ipq,
                                               min_sn,
                                               criteria_to_consider)
if (!uncalibrated_as_NA) {
  checked_data <- dplyr::mutate(
    checked_data,
    analyte_meets_criteria = tidyr::replace_na(analyte_meets_criteria,
                                               FALSE)
  )
}

summarized_checks <- summarize_spectra_checks(checked_data)

group_keyword = NULL
control_sample_types = c("PBS")
percentile = 95
use_mean_SD = FALSE
SD_factor = 3

cut_offs <- calculate_cut_offs(summarized_checks,
                               control_sample_types,
                               percentile = 95,
                               uncalibrated_as_NA = uncalibrated_as_NA)

summarized_checks_with_cut_offs <- dplyr::left_join(summarized_checks, 
                                                      cut_offs) %>% 
    dplyr::ungroup(.)

curated_spectra <- summarized_checks_with_cut_offs %>% 
    # Can't use all() instead of & because all() is not vectorized
    dplyr::mutate(has_passed_spectra_curation = passing_analyte_percentage > cut_off_passing_analyte_percentage &
                    sum_intensity > cut_off_sum_intensity) 

with_reasons <- curated_spectra %>% 
    dplyr::mutate(reason_for_failure = dplyr::case_when(
      uncalibrated ~ "Calibration failed.",
        passing_analyte_percentage <= cut_off_passing_analyte_percentage & sum_intensity <= cut_off_sum_intensity ~ "Percentage of passing analytes and sum intensity below cut-offs.",
        passing_analyte_percentage <= cut_off_passing_analyte_percentage ~ "Percentage of passing analytes below cut-off.",
        sum_intensity <= cut_off_sum_intensity ~ "Sum intensity below cut-off.",
        TRUE ~ as.character(NA) # Cannot be NA, because case_When requires that all possible 
        # values are of the same type (in this case string)
      ))

curated_data <- curate_spectra(checked_data = checked_data,
                               summarized_checks = summarized_checks,
                               cut_offs = cut_offs,
                               uncalibrated_as_NA = uncalibrated_as_NA)

plotly::ggplotly(create_cut_off_plot(summarized_checks))

for_plot <- summarized_checks %>% 
  dplyr::mutate(uncalibrated = ifelse(is.na(sum_intensity) & is.na(passing_analyte_percentage),
                                      TRUE,
                                      FALSE)#,
                # dplyr::across(.cols = c(sum_intensity, passing_analyte_percentage),
                #               .fns = ~ tidyr::replace_na(.x, 0))
                ) %>% 
  tidyr::replace_na(replace = list(sum_intensity = 0,
                                   passing_analyte_percentage = 0))

n_colors <- length(unique(for_plot$sample_type))
  my_palette <- colorRampPalette(RColorBrewer::brewer.pal(8, "Set2"))(n_colors)
  
  p <- for_plot %>% 
    ggplot2::ggplot() +
    ggplot2::geom_jitter(data = for_plot[!for_plot$uncalibrated, ],
                         ggplot2::aes(color = sample_type,
                                      x = passing_analyte_percentage,
                                      y = sum_intensity,
                                      text = paste0("Sample name: ", 
                                                    sample_name,
                                                    "\n",
                                                    "Sample ID: ",
                                                    sample_id,
                                                    "\n",
                                                    "Passing analyte percentage: ",
                                                    passing_analyte_percentage,
                                                    "\n",
                                                    "Sum intensity: ",
                                                    sum_intensity,
                                                    "\nUncalibrated: ",
                                                    uncalibrated)),
                         size = 1,
                         alpha = 0.7) +
    ggplot2::geom_jitter(data = for_plot[for_plot$uncalibrated, ],
                         ggplot2::aes(color = sample_type,
                                      x = passing_analyte_percentage,
                                      y = sum_intensity,
                                      text = paste0("Sample name: ", 
                                                    sample_name,
                                                    "\n",
                                                    "Sample ID: ",
                                                    sample_id,
                                                    "\n",
                                                    "Passing analyte percentage: ",
                                                    passing_analyte_percentage,
                                                    "\n",
                                                    "Sum intensity: ",
                                                    sum_intensity,
                                                    "\nUncalibrated: ",
                                                    uncalibrated)),
                         shape = 15,
                         size = 1,
                         alpha = 0.7,
                         width = 0.01) +
    ggplot2::theme_classic() +
    ggplot2::theme(panel.border = ggplot2::element_rect(colour = "black", fill=NA, size=0.5),
                   strip.background = ggplot2::element_rect(fill = "#F6F6F8")) +
    ggplot2::scale_color_manual(values = my_palette,
                                name = "Sample type") +
    ggplot2::labs(y = "Sum intensity of passing analytes") +
    ggplot2::scale_x_continuous(labels = function(x) paste0(x * 100, "%"), 
                                name = "Percentage of passing analytes")
  
  if ("group" %in% colnames(for_plot)) {
    p <- p +
      ggplot2::facet_wrap(cluster ~ group)
  } else {
    p <- p +
      ggplot2::facet_wrap(~ cluster)
  }

pl <- plotly::ggplotly(p, tooltip = "text")

pl

my_data <- curated_data %>% 
    dplyr::distinct(dplyr::across(tidyselect::any_of(c("group", 
                                                       "sample_type", 
                                                       "cluster", 
                                                       "sample_name", 
                                                       "has_passed_spectra_curation",
                                                       "reason_for_failure")))) 

reasons <- unique(my_data$reason_for_failure)
reason_labels <- firstlower(reasons) %>% 
  tidyr::replace_na(., "Yes")
reason_labels[reason_labels != "Yes"] <- paste("No,", reason_labels[reason_labels != "Yes"])

reason_labels <- purrr::map_chr(
  reason_labels,
  function(label) {
    if (nchar(label) > 20) {
      last_20_chars <- substr(label, 20, nchar(label))
      replacement <- stringr::str_replace(last_20_chars, 
                                          " ",
                                          "\n")
      substr(label, 20, nchar(label)) <- replacement
    }
    return(label)
  })

# Set the names to the 'old' values in the data, so that this named vector can
# be used to recode reason_for_failure with nice:
names(reason_labels) <- paste(reasons) # paste() converts NA to "NA"


my_data <- my_data %>% 
    dplyr::mutate(
      `Passed curation?` = dplyr::recode(
        paste(reason_for_failure), # to convert NA to "NA"
        !!!reason_labels
      ) # recode() can't take a named vector as an argument, use !!! to 'unlist' it
    ) %>% 
  calculate_number_and_percentage_per_reason()

n_colors <- length(unique(my_data$reason_for_failure)) - 1
  my_palette <- c(colorRampPalette(RColorBrewer::brewer.pal(8, "OrRd")[5:8])(n_colors),
                  "#3498DB")

plot <- my_data %>% 
    ggplot2::ggplot() +
    ggplot2::geom_bar(ggplot2::aes(x = sample_type,
                                   fill = `Passed curation?`,
                                   text = paste(
                                     "Number of spectra:",
                                     number,
                                     "\nPercentage of spectra:",
                                     percentage
                                   )), 
                      position = "fill") +
    ggplot2::xlab("Sample type") +
    ggplot2::scale_y_continuous(labels = function(x) paste0(x * 100, "%"), 
                                name = "Proportion of spectra (%)") +
    ggplot2::scale_fill_manual(values = my_palette) +
    ggplot2::theme_classic() +
    ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
                   strip.background = ggplot2::element_rect(fill = "#F6F6F8"),
                   panel.border = ggplot2::element_rect(colour = "black", fill=NA, size=0.5))
  
  if (Ig_data == "Yes") {
    plot <- plot +
      ggplot2::facet_wrap(cluster ~ group)
  } else {
    plot <- plot +
      ggplot2::facet_wrap(~ cluster)
  }


plotly_object <- plotly::ggplotly(plot, tooltip = "text")

plotly_object <- facet_strip_bigger(plotly_object)

plotly_object <- change_axis_title_distance(plotly_object)

plotly_object

passing_spectra <- curated_data %>% 
  dplyr::filter(has_passed_spectra_curation) %>% 
  dplyr::select(-c(reason_for_failure,
                   passing_analyte_percentage,
                   cut_off_sum_intensity,
                   cut_off_passing_analyte_percentage,
                   curation_method,
                   analyte_meets_criteria,
                   failed_criteria,
                   sample_type_list))

passing_spectra

```

## Analyte curation

```{r analyte-curation}

checked_analytes <- check_analyte_quality_criteria(passing_spectra,
                                                   min_ppm_deviation = min_ppm_deviation,
                                                   max_ppm_deviation = max_ppm_deviation,
                                                   max_ipq = max_ipq,
                                                   min_sn = min_sn,
                                                   criteria_to_consider = c("IPQ", "S/N", "Mass accuracy"),
                                                   uncalibrated_as_NA = uncalibrated_as_NA)

curated_analytes <- curate_analytes(checked_analytes,
                                    cut_off_percentage = 25)

analyte_curated_data <- dplyr::left_join(curated_analytes, 
                                         passing_spectra)

plot <- plot_analyte_curation(curated_analytes = curated_analytes,
                              cut_off_percentage = 25,
                              selected_cluster = "IgGI1") 

plotly::ggplotly(plot, tooltip = "text")

dataframe_for_table <- prepare_analyte_curation_table(
  analyte_curated_data = analyte_curated_data,
  selected_cluster = "IgGI1")

charge_columns <- colnames(dataframe_for_table)[-1]

to_check <- dataframe_for_table %>% 
  dplyr::filter(dplyr::if_any(tidyselect::all_of(charge_columns),
                              ~ .x == "Yes")) %>% 
  dplyr::pull(analyte)

to_check_indices <- which(dataframe_for_table$analyte %in% to_check)

ids_to_check <- sapply(paste0("checkbox", charge_columns), 
                       paste0,
                       to_check_indices) %>% 
  c()

dataframe_for_table

charge_columns <- colnames(dataframe_for_table)[-1]

analytes_to_include <- rlang::set_names(charge_columns) %>% 
  purrr::map_dfc(.,
                 function(charge_column) {
                   print(charge_column)
                   ifelse(dataframe_for_table[[charge_column]] == "Yes",
                          dataframe_for_table$analyte,
                          NA)
                 }) %>% 
  tidyr::pivot_longer(
    tidyselect::everything(),
    names_to = "charge",
    values_to = "analyte"
  ) %>% 
  dplyr::filter(!is.na(analyte)) %>% 
  dplyr::mutate(dplyr::across(analyte, as.character))

data_for_norm <- dplyr::left_join(analytes_to_include,
                                  data_curated)

# Maybe a plot (faceted by charge) with for each failed analyte the proportion
# of failed analyte QC's?

to_plot <- analyte_curated_data %>% 
  dplyr::filter(passed_curation == FALSE)

ggplot2::ggplot(to_plot,
                ggplot2::aes(x = analyte,
                             fill = failed_criteria)) +
  ggplot2::geom_bar(position = "fill") +
  ggplot2::scale_y_continuous(labels = function(x) paste0(x * 100, "%"), 
                              name = "Proportion of spectra (%)") +
  #ggplot2::scale_fill_manual() +
  ggplot2::theme_classic() +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
                 strip.background = ggplot2::element_rect(fill = "#F6F6F8"),
                 panel.border = ggplot2::element_rect(colour = "black", fill=NA, size=0.5))
  
for_upset <- to_plot %>% 
  tidyr::extract(failed_criteria,
                 into = c("mass_acc_failed"),
                 regex = ".*(mass accuracy).*",
                 remove = FALSE) %>% 
  tidyr::extract(failed_criteria,
                 into = "IPQ_failed",
                 regex = ".*(IPQ).*",
                 remove = FALSE) %>% 
  tidyr::extract(failed_criteria,
                 into = "SN_failed",
                 regex = ".*(S/N).*",
                 remove = FALSE) %>% 
  dplyr::mutate(across(c(mass_acc_failed,
                         IPQ_failed,
                         SN_failed),
                       ~ !is.na(.x))) %>% 
  dplyr::ungroup() %>% 
  dplyr::mutate(specific_total = group,
                .keep = "unused") %>% 
  dplyr::group_split(analyte, charge)

# purrr::map(for_upset,
#            ~ my_upset(.x) %>% 
#              ggpubr::ggpar(., title = paste(unique(.x$analyte), unique(.x$charge))))
# 
# my_upset <- function(my_data) {
#   ComplexUpset::upset(my_data,
#                     intersect = c("mass_acc_failed", "IPQ_failed", "SN_failed"),
#                     base_annotations = list(
#                       "Sample types" = list(
#                         aes = ggplot2::aes(x = intersection,
#                                      fill = sample_type),
#                         geom = list(ggplot2::geom_bar(stat = "count", position = "stack"))
#                       )
#                     ),
#                     set_sizes = (
#                       upset_set_size(
#                         geom = ggplot2::geom_bar(
#                           ggplot2::aes(fill = sample_type, x = group),
#                           width = 0.8
#                         ),
#                         position='right'
#                       )
#                     )
#   )
# }
# 
# my_venn <- function(my_data) {
#   
# }


```

```{r normalization}

total_intensities <- calculate_total_intensity(data = data_for_norm)
normalized_data <- normalize_data(data = total_intensities) 
normalized_data_wide <- normalized_data %>% 
        # removing columns with values that differ between clusters:
        dplyr::select(-tidyselect::any_of(c("passing_analyte_percentage", 
                                            "cut_off_passing_analyte_percentage", 
                                            "cut_off_sum_intensity",
                                            "failed_criteria"))) %>% 
        tidyr::pivot_wider(names_from = c(cluster, analyte),
                           names_sep = "_",
                           values_from = relative_abundance)

#normalized_data_wide <- normalized_data_wide %>% dplyr::select(-group)

menu <- normalized_data %>% 
  dplyr::select(tidyselect::any_of(c("sample_name", "group", "sample_id"))) %>%
  dplyr::distinct() %>%
  dplyr::group_by(dplyr::across(tidyselect::any_of("group"))) %>% 
  dplyr::add_count(sample_id, name = "number_of_replicates_after_curation") %>% 
  dplyr::mutate(number_of_replicates_after_curation = ifelse(sample_id == "empty cell in plate design",
                                              1,
                                              number_of_replicates_after_curation)) %>% 
  dplyr::mutate(replicates_after_curation = number_of_replicates_after_curation > 1) %>% 
  dplyr::distinct(dplyr::across(tidyselect::any_of(c("group", "sample_id")))) %>% 
  purrr::pmap_chr(.,
                  paste)

selected_sample_id <- stringr::str_extract(menu[2],
                                             unique(normalized_data$sample_id)) %>% 
  na.omit()

if ("group" %in% colnames(normalized_data)) {
  selected_group <- stringr::str_extract(
    string = menu[2],
    pattern = unique(normalized_data$group)) %>% 
    na.omit(.)
} else {
  selected_group <- NULL
}

repeatability <- calculate_repeatability_stats(normalized_data,
                                               selected_sample_id,
                                               selected_group)

dodged_barplot <- visualize_repeatability_dogded_bars(normalized_data,
                                    selected_sample_id,
                                    selected_group)

mean_barplot <- visualize_repeatability_mean_bars(normalized_data,
                                    selected_sample_id,
                                    selected_group)

plotly::ggplotly(dodged_barplot, tooltip = "text")
plotly::ggplotly(mean_barplot, tooltip = "text")

        
plot <- visualize_repeatability2(repeatability)

pl <- plotly::ggplotly(plot, tooltip = "text")

pl <- change_axis_title_distance(pl, y_distance = 90)

pl

```

```{r exploration, eval=FALSE}

derived_traits <- calculate_derived_traits(normalized_data, c("Fucosylation", "Sialylation", "Bisection", "Galactosylation"))

formulas <- derived_traits %>% 
  dplyr::ungroup() %>% 
  dplyr::select(tidyselect::ends_with("formula")) %>% 
  dplyr::distinct() %>% 
  tidyr::pivot_longer(cols = tidyselect::everything(),
                      names_to = "Derived trait",
                      values_to = "Formula") %>% 
  dplyr::mutate(`Derived trait` = dplyr::recode(`Derived trait`,
                                                fuc_formula = "Fucosylation",
                                                gal_formula = "Galactosylation",
                                                sial_formula = "Sialylation",
                                                bis_formula = "Bisection"))

DT::datatable(formulas, rownames = FALSE, options = list(paging = FALSE,
                                                         ordering = FALSE,
                                                         searching = FALSE))
      
data_with_derived_traits <- dplyr::full_join(
  normalized_data_wide,
  derived_traits %>% dplyr::select(-tidyselect::ends_with("formula"))) %>% 
  tidyr::pivot_wider(names_from = cluster,
                     values_from = dplyr::any_of(c("Fucosylation",
                                                   "Galactosylation",
                                                   "Bisection",
                                                   "Sialylation")),
                     names_glue = "{cluster}_{.value}")

pl <- my_boxplot(data_with_derived_traits, 
                 "sample_type", 
                 "IgGI1_Fucosylation", 
                 facets = c("group", "sample_type")) 

pl <- my_histogram(data_with_derived_traits,
                   "IgGI1_Fucosylation",
                   color = "sample_type")

boxplot_traces <- 1:nfacets(pl)

plotly::ggplotly(pl, tooltip = "text") #%>% 
  plotly::style(hoverinfo = "y", traces = boxplot_traces) %>% 
  hide_outliers(.)





```

